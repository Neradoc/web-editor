<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>CircuitPython WebBluetooth Test</title>
  </head>
  <body>
    <h1>CircuitPython WebBluetooth Test</h1>
<p>
Make sure you have enabled two flags in chrome://flags:
* <a href="chrome://flags/#enable-experimental-web-platform-features">chrome://flags/#enable-experimental-web-platform-features</a>
* <a href="chrome://flags/#enable-web-bluetooth-new-permissions-backend">chrome://flags/#enable-web-bluetooth-new-permissions-backend</a>

These flags allow the page to reconnect to devices you've already granted them access to.
</p>
<p>
The first step is selecting the USB serial device you want to use.
</p>
<button id="requestSerialDevice">Request Serial Device</button>
<p>
The first step is selecting the device you want to use.
</p>
<button id="requestBluetoothDevice">Request Bluetooth Device</button>
<p>
If you've done this before and the persistent device API works, then you can click this intead:
</p>
<button id="connectToBluetoothDevices">Connect to Bluetooth Devices</button>
<p>
Once you are connected, we need to prompt a bond. Without this CircuitPython boards with USB won't continue to advertise after a hard reset or powerloss.
</p>
<button id="promptBond">Bond</button>

<div id="terminal"
     style="position:relative; width:100%; height:200px"></div>

<div id="editor"></div>
<script src='./hterm_all.js'></script>
<script type="module">

import {FileTransferClient} from './_snowpack/pkg/@adafruit/ble-file-transfer.js';
const bleNusServiceUUID  = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
const bleNusCharRXUUID   = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
const bleNusCharTXUUID   = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

var bleDevice;
var serialDevice;
var bleServer;
var serialService;
var rxCharacteristic;
var txCharacteristic;
var client;
var terminal;
var decoder = new TextDecoder();

let connect = document.querySelector('#connectToBluetoothDevices');
let request = document.querySelector('#requestBluetoothDevice');
let bond = document.querySelector('#promptBond');
let request_serial = document.querySelector('#requestSerialDevice');

var connected = false;

async function onConnectToBluetoothDevicesButtonClick() {
  try {
    console.log('Getting existing permitted Bluetooth devices...');
    const devices = await navigator.bluetooth.getDevices();

    console.log('> Got ' + devices.length + ' Bluetooth devices.');
    // These devices may not be powered on or in range, so scan for
    // advertisement packets from them before connecting.
    for (const device of devices) {
      connectToBluetoothDevice(device);
    }
  }
  catch(error) {
    console.log('Argh! ' + error);
  }
}

async function switchToDevice(device) {
  bleDevice = device;
  bleDevice.addEventListener("gattserverdisconnected", onDisconnected);
  bleServer = bleDevice.gatt;
  console.log("connected", bleServer);

  const services = await bleServer.getPrimaryServices();
  console.log(services);

  console.log('Getting Transfer Service...');
  client = new FileTransferClient(bleDevice);

  serialService = await bleServer.getPrimaryService(bleNusServiceUUID);
  // TODO: create a terminal for each serial service
  txCharacteristic = await serialService.getCharacteristic(bleNusCharTXUUID);
  rxCharacteristic = await serialService.getCharacteristic(bleNusCharRXUUID);
  console.log(txCharacteristic, rxCharacteristic);
  bond.disabled = false;
  connect.disabled = true;
  request.disabled = true;
}

async function onSerialConnected(e) {
  console.log(e, "connected!");
}

async function onSerialDisconnected(e) {
  console.log(e, "disconnected");
}

async function switchToSerial(device) {
  if (serialDevice) {
    await serialDevice.close();
  }
  serialDevice = device;
  device.addEventListener("connect", onSerialConnected);
  device.addEventListener("disconnect", onSerialDisconnected);
  console.log("switch to", device);
  await device.open({baudRate: 115200});
  console.log("opened");
  let reader;
  while (device.readable) {
    reader = device.readable.getReader();
    try {
      while (true) {
        const { value, done } = await reader.read();
        if (done) {
          // |reader| has been canceled.
          break;
        }
        terminal.io.print(decoder.decode(value));
      }
    } catch (error) {
      // Handle |error|...
      console.log("error", error);
    } finally {
      reader.releaseLock();
    }
  }

}

async function connectToBluetoothDevice(device) {
  const abortController = new AbortController();

  device.addEventListener('advertisementreceived', async (event) => {
    console.log('> Received advertisement from "' + device.name + '"...');
    // Stop watching advertisements to conserve battery life.
    abortController.abort();
    console.log('Connecting to GATT Server from "' + device.name + '"...');
    try {
      await device.gatt.connect()
      console.log('> Bluetooth device "' +  device.name + ' connected.');
      await switchToDevice(device);
    }
    catch(error) {
      console.log('Argh! ' + error);
    }
  }, { once: true });

  try {
    console.log('Watching advertisements from "' + device.name + '"...');
    await device.watchAdvertisements({ signal: abortController.signal });
  }
  catch(error) {
    console.log('Argh! ' + error);
  }
}

var unchanged = 0;
async function onBond() {
  console.log("bond");
  await client.bond();
  var contents = await client.readFile("/code.py");
  editor.setState(EditorState.create({
    doc: contents,
    extensions: [
    basicSetup,
    python(),
    EditorView.updateListener.of(onTextChange)]
  }));
  unchanged = editor.state.doc.length;
  console.log("doc length", unchanged);
  console.log("bond done");
}

async function onDisconnected() {
  console.log('disconnected');
  await bleServer.connect();
}

async function onRequestBluetoothDeviceButtonClick() {
  try {
    console.log('Requesting any Bluetooth device...');
    bleDevice = await navigator.bluetooth.requestDevice({
     filters: [{services: [0xfebb]},], // <- Prefer filters to save energy & show relevant devices.
     // acceptAllDevices: true,,
      optionalServices: [0xfebb, bleNusServiceUUID]
    });

    console.log('> Requested ' + bleDevice.name);
    await bleDevice.gatt.connect();
    switchToDevice(bleDevice);
  }
  catch(error) {
    console.log('Argh! ' + error);
  }
}

async function onRequestSerialDeviceButtonClick() {
  let devices = await navigator.serial.getPorts()
  if (devices.length == 1) {
    let device = devices[0];
    switchToSerial(device);
    return;
  }
  try {
    console.log('Requesting any serial device...');
    let device = await navigator.serial.requestPort();

    console.log('> Requested ');
    console.log(device);
    switchToSerial(device);
    return;
  }
  catch(error) {
    console.log('Argh! ');
  }
}

var editor;
var currentTimeout = null;
async function writeText() {
    console.log("sync starting at", unchanged, "to", editor.state.doc.length);
    if (!client) {
      console.log("no client");
      return;
    }
    let encoder = new TextEncoder();
    let doc = editor.state.doc;
    let same = doc.sliceString(0, unchanged);
    let offset = encoder.encode(same).byteLength
    let different = doc.sliceString(unchanged);
    let contents = encoder.encode(different);
    console.log(offset, different);
    let oldUnchanged = unchanged;
    unchanged = doc.length;
    try {
        console.log("write");
        await client.writeFile("/code.py", offset, contents);
    } catch (e) {
        console.log("write failed", e, e.stack);
        unchanged = Math.min(oldUnchanged, unchanged);
        if (currentTimeout != null) {
            clearTimeout(currentTimeout);
        }
        currentTimeout = setTimeout(writeText, 2000);
    }
}

async function onTextChange(update) {
  if (!update.docChanged) {
    return;
  }
  var hasGap = false;
  update.changes.desc.iterGaps(function(posA, posB, length) {
    // this are unchanged gaps.
    hasGap = true;
    if (posA != 0 && posB != 0) {
        return;
    } else if (posA == 0 && posB == 0) {
        unchanged = Math.min(length, unchanged);
    } else {
        unchanged = 0;
    }
  });
  // Everything has changed.
  if (!hasGap) {
    unchanged = 0;
  }

  if (currentTimeout != null) {
    clearTimeout(currentTimeout);
  }
  currentTimeout = setTimeout(writeText, 750);
}

if (navigator.bluetooth) {
  connect.addEventListener('click', function() {
      onConnectToBluetoothDevicesButtonClick();
  });
  request.addEventListener('click', function() {
      onRequestBluetoothDeviceButtonClick();
  });
  bond.addEventListener('click', function() {
      onBond();
  });

  bond.disabled = true;

} else {
  console.log("bluetooth not supported on this browser");
}

if (navigator.serial) {
  request_serial.addEventListener('click', function() {
    onRequestSerialDeviceButtonClick();
  });
} else {
  request_serial.disabled = true;
}

import {EditorState, EditorView, basicSetup} from "./_snowpack/pkg/@codemirror/basic-setup.js"
import {python} from "./_snowpack/pkg/@codemirror/lang-python.js"

editor = new EditorView({
  state: EditorState.create({
    doc: "Connect to load code.py",
    extensions: [basicSetup]
  }),
  parent: document.querySelector('#editor')
})

function setupHterm() {
  // hterm.defaultStorage = new lib.Storage.Local();
  // profileId is the name of the terminal profile to load, or "default" if
  // not specified.  If you're using one of the persistent storage
  // implementations then this will scope all preferences read/writes to this
  // name.
  const t = new hterm.Terminal();
  terminal = t;
  t.onTerminalReady = function() {
    // Create a new terminal IO object and give it the foreground.
    // (The default IO object just prints warning messages about unhandled
    // things to the the JS console.)
    const io = t.io.push();

    io.onVTKeystroke = async (s) => {
      // Do something useful with str here.
      // For example, Secure Shell forwards the string onto the NaCl plugin.
      // console.log("key", s);
      if (serialDevice && serialDevice.writable) {
        const encoder = new TextEncoder();
        const writer = serialDevice.writable.getWriter();
        await writer.write(encoder.encode(s));
        writer.releaseLock();
      }
    };

    io.sendString = async (str) => {
      // Just like a keystroke, except str was generated by the terminal itself.
      // For example, when the user pastes a string.
      // Most likely you'll do the same thing as onVTKeystroke.
      // console.log("paste", str);
      if (serialDevice && serialDevice.writable) {
        const encoder = new TextEncoder();
        const writer = serialDevice.writable.getWriter();
        await writer.write(encoder.encode(str));
        writer.releaseLock();
      }
    };

    io.onTerminalResize = (columns, rows) => {
      // React to size changes here.
      // Secure Shell pokes at NaCl, which eventually results in
      // some ioctls on the host.
      console.log("resize", columns, rows);
    };

    // You can call io.push() to foreground a fresh io context, which can
    // be uses to give control of the terminal to something else.  When that
    // thing is complete, should call io.pop() to restore control to the
    // previous io object.
  };
  t.decorate(document.querySelector('#terminal'));
  t.installKeyboard();
  t.io.print('Print a string without a newline');
  t.io.println('Print a string and add CRLF');


}

// This will be whatever normal entry/initialization point your project uses.
window.onload = async function() {
  await lib.init();
  setupHterm();
};

</script>

  </body>
</html>
